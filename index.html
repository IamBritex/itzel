<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Itzel Test</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      touch-action: none; /* evita scroll accidental */
    }
    canvas {
      border: 2px solid #444;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0,0,0,0.6);
      display: block;
    }
  </style>
</head>
<body>
  <!-- El canvas mantiene resoluciÃ³n interna fija -->
  <canvas id="parallaxCanvas" width="1080" height="1080"></canvas>

  <script>
    const canvas = document.getElementById("parallaxCanvas");
    const ctx = canvas.getContext("2d");

    // Escalar canvas al estilo Phaser "FIT"
    function resizeCanvas() {
      const aspect = canvas.width / canvas.height;
      let newWidth = window.innerWidth;
      let newHeight = window.innerHeight;

      if (newWidth / newHeight > aspect) {
        newWidth = newHeight * aspect;
      } else {
        newHeight = newWidth / aspect;
      }

      canvas.style.width = newWidth + "px";
      canvas.style.height = newHeight + "px";
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ConfiguraciÃ³n de imÃ¡genes
    const config = {
      img1: {
        src: "img/character.png",
        x: 200,
        y: 80,
        scale: 1,
        speed: 0.03,
        zIndex: 1
      },
      img2: {
        src: "img/varas.png",
        x: -80,
        y: -210,
        scale: 1.3,
        speed: 0.10,
        zIndex: 2
      }
    };

    const images = {
      img1: new Image(),
      img2: new Image()
    };

    let mouse = { x: 0, y: 0 };
    let loaded = 0;

    // Cargar imÃ¡genes
    Object.keys(images).forEach((key) => {
      images[key].src = config[key].src;
      images[key].onload = () => {
        loaded++;
        if (loaded === 2) draw();
      };
    });

    // ðŸ“Œ PC â†’ Movimiento con mouse
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left - rect.width / 2;
      mouse.y = e.clientY - rect.top - rect.height / 2;
    });

    // ðŸ“Œ MÃ³viles â†’ Movimiento con dedo
    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        mouse.x = touch.clientX - rect.left - rect.width / 2;
        mouse.y = touch.clientY - rect.top - rect.height / 2;
      }
    });

    // ðŸ“Œ Giroscopio (si estÃ¡ disponible)
    if (window.DeviceOrientationEvent) {
      window.addEventListener("deviceorientation", (e) => {
        // Rango normal: gamma (-90 a 90), beta (-180 a 180)
        const gamma = e.gamma || 0; // izquierda/derecha
        const beta = e.beta || 0;   // adelante/atrÃ¡s

        // Mapeamos valores a un rango "suave"
        mouse.x = gamma * 10;
        mouse.y = beta * 5;
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Ordenar imÃ¡genes segÃºn zIndex
      const layers = Object.keys(config).sort(
        (a, b) => config[a].zIndex - config[b].zIndex
      );

      // Dibujar en orden
      layers.forEach((key) => {
        const img = images[key];
        const cfg = config[key];
        ctx.save();
        ctx.translate(cfg.x + mouse.x * cfg.speed, cfg.y + mouse.y * cfg.speed);
        ctx.scale(cfg.scale, cfg.scale);
        ctx.drawImage(img, 0, 0);
        ctx.restore();
      });

      requestAnimationFrame(draw);
    }
  </script>
</body>
</html>
